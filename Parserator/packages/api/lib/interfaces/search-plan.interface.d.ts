/**
 * Core interfaces for the Parserator Architect-Extractor pattern
 * Defines the structure of SearchPlans used to coordinate the two-stage parsing process
 */
/**
 * Validation types supported by the parsing engine
 */
export type ValidationTypeEnum = 'string' | 'email' | 'number' | 'iso_date' | 'string_array' | 'boolean' | 'url' | 'phone' | 'json_object';
/**
 * Individual step in a SearchPlan
 * Each step represents one piece of data to extract from the input
 */
export interface ISearchStep {
    /** The key for the final JSON output (e.g., "customerName") */
    targetKey: string;
    /** Human-readable description of what this data represents */
    description: string;
    /** Direct instruction for the Extractor LLM on how to find this data */
    searchInstruction: string;
    /** Type validation hint for the extracted value */
    validationType: ValidationTypeEnum;
    /** Whether this field must be found (affects confidence scoring) */
    isRequired: boolean;
    /** Optional examples to help the Extractor understand the expected format */
    examples?: string[];
    /** Optional regex pattern for additional validation */
    pattern?: string;
    /** Default value to use if extraction fails and field is not required */
    defaultValue?: any;
}
/**
 * Complete SearchPlan generated by the Architect
 * Contains all steps needed to extract structured data from unstructured input
 */
export interface ISearchPlan {
    /** Array of extraction steps to execute */
    steps: ISearchStep[];
    /** Total number of steps (for validation) */
    totalSteps: number;
    /** Estimated complexity of the parsing task */
    estimatedComplexity: 'low' | 'medium' | 'high';
    /** Confidence score from the Architect (0.0 to 1.0) */
    architectConfidence: number;
    /** Estimated tokens needed for the Extractor stage */
    estimatedExtractorTokens: number;
    /** Any special instructions for the Extractor */
    extractorInstructions?: string;
    /** Metadata about the plan generation */
    metadata: {
        /** Timestamp when plan was created */
        createdAt: string;
        /** Version of the Architect prompt used */
        architectVersion: string;
        /** Sample data length used for planning */
        sampleLength: number;
        /** User-provided instructions that influenced the plan */
        userInstructions?: string;
    };
}
/**
 * Result from the Architect stage
 * Contains the SearchPlan plus metadata about the planning process
 */
export interface IArchitectResult {
    /** The generated SearchPlan */
    searchPlan: ISearchPlan;
    /** Tokens consumed by the Architect */
    tokensUsed: number;
    /** Processing time for the Architect stage */
    processingTimeMs: number;
    /** Model used for the Architect */
    model: string;
    /** Success indicator */
    success: boolean;
    /** Error details if planning failed */
    error?: {
        code: string;
        message: string;
        details?: Record<string, unknown>;
    };
}
/**
 * Result from the Extractor stage
 * Contains the parsed data plus metadata about the extraction process
 */
export interface IExtractorResult {
    /** The extracted and structured data */
    parsedData: Record<string, any>;
    /** Confidence scores for each extracted field */
    fieldConfidence: Record<string, number>;
    /** Overall confidence score for the extraction */
    overallConfidence: number;
    /** Tokens consumed by the Extractor */
    tokensUsed: number;
    /** Processing time for the Extractor stage */
    processingTimeMs: number;
    /** Model used for the Extractor */
    model: string;
    /** Success indicator */
    success: boolean;
    /** Fields that failed to extract (for debugging) */
    failedFields: string[];
    /** Error details if extraction failed */
    error?: {
        code: string;
        message: string;
        details?: Record<string, unknown>;
    };
}
/**
 * Complete parsing result combining both stages
 * This is what gets returned to the end user
 */
export interface IParseResult {
    /** Success indicator */
    success: boolean;
    /** The final parsed and structured data */
    parsedData: Record<string, any>;
    /** Metadata about the parsing process */
    metadata: {
        /** The SearchPlan that was generated and used */
        architectPlan: ISearchPlan;
        /** Overall confidence score (0.0 to 1.0) */
        confidence: number;
        /** Total tokens used across both stages */
        tokensUsed: number;
        /** Total processing time across both stages */
        processingTimeMs: number;
        /** Tokens used by the Architect */
        architectTokens: number;
        /** Tokens used by the Extractor */
        extractorTokens: number;
        /** Processing breakdown by stage */
        stageBreakdown: {
            architect: {
                timeMs: number;
                tokens: number;
                confidence: number;
            };
            extractor: {
                timeMs: number;
                tokens: number;
                confidence: number;
            };
        };
    };
    /** Error details if parsing failed */
    error?: {
        code: string;
        message: string;
        stage: 'architect' | 'extractor' | 'validation' | 'orchestration';
        details?: Record<string, unknown>;
    };
}
/**
 * Validation result for extracted data
 * Used to ensure the output matches expected formats
 */
export interface IValidationResult {
    /** Whether validation passed */
    isValid: boolean;
    /** Fields that passed validation */
    validFields: string[];
    /** Fields that failed validation */
    invalidFields: string[];
    /** Detailed validation errors by field */
    fieldErrors: Record<string, string>;
    /** Overall validation score (0.0 to 1.0) */
    validationScore: number;
    /** Suggestions for fixing validation errors */
    suggestions: string[];
}
//# sourceMappingURL=search-plan.interface.d.ts.map